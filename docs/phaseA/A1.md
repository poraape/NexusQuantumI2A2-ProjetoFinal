# A1 — Inspeção de Dependências e Ciclos

## Visão Geral
O repositório atual organiza toda a orquestração da aplicação em `App.tsx`, que importa diretamente componentes de UI e múltiplos serviços utilitários. O serviço `services/geminiService.ts` concentra a integração com a API Gemini, chamando internamente parsers, classificadores e a fila sequencial de chamadas. Outros serviços, como `services/exporter.ts`, encadeiam validação e projeções fiscais, reforçando o acoplamento entre módulos operacionais e cognitivos.

## Ciclos Detectados
Uma varredura manual nas importações revelou um único ciclo indireto envolvendo `services/geminiService.ts` ⇄ `services/classifier.ts`. O classificador utiliza `callGeminiWithRetry` exportado pelo próprio serviço de IA, o que força a instrumentação do classificador a depender de detalhes de fila síncrona definidos em `geminiService`. Como `geminiService` também invoca o classificador para refinar relatórios, forma-se um ciclo conceitual.

| # | Caminho do Ciclo | Impacto | Recomendações |
|---|------------------|---------|---------------|
| 1 | `geminiService -> classifier -> geminiService` | Compartilhamento forçado de filas síncronas; risco de deadlock na transição para mensageria. | Extrair interface `IGenerativeClient` e permitir que o classificador dependa apenas da interface. |

Nenhum outro ciclo foi identificado após a análise dos imports de `services/` e `components/`.

## Sugestões de Extração de Interfaces
- **Camada de IA**: introduzir `IGenerativeClient` e `ITaskQueue` para desacoplar `classifier`, `chatService` e demais consumidores da fila compartilhada definida em `geminiService`. Isso permitirá substituir a fila por um barramento distribuído sem alterar chamadas existentes.
- **Camada de Memória**: definir `IContextStore` para isolar o acesso ao `localStorage`. Módulos `contextMemory`, `chatService` e `rulesValidator` utilizariam apenas métodos declarados, facilitando migração futura para um backend multiagente.
- **Exportação e Validação**: encapsular `extrairDadosParaExportacao` e `validateDocument` em um `IFiscalDataPipeline`, evitando o acesso direto a implementações síncronas dentro do browser.

## Evidências
- `App.tsx` importa `services/geminiService`, `services/exporter`, `services/classifier`, `services/forecast` e `services/contextMemory`, centralizando toda a lógica de orquestração em um único componente React. 【F:App.tsx†L1-L32】【F:App.tsx†L116-L205】
- `services/geminiService.ts` expõe `callGeminiWithRetry` e a fila global `enqueueGeminiCall`, sendo consumido por `services/classifier.ts`. 【F:services/geminiService.ts†L1-L120】【F:services/classifier.ts†L1-L63】
- `services/exporter.ts` aciona `services/rulesValidator.ts` e `services/forecast.ts` antes de retornar dados para download, reforçando acoplamento operacional. 【F:services/exporter.ts†L1-L120】

## Próximos Passos Automatizados
1. Converter o grafo `artifacts/deps.mmd` em imagem durante a pipeline de CI usando `@mermaid-js/mermaid-cli` quando disponível.
2. Adicionar lint personalizado para detectar ciclos (ex.: `madge --circular`) como parte da esteira de build.
3. Encapsular as novas interfaces em `services/ports/` e mover implementações atuais para `services/adapters/`.
